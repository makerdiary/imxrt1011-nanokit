{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"LICENSE/","title":"License","text":"<p>Apache License</p> <p>Version 2.0, January 2004</p> <p>http://www.apache.org/licenses/</p> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <p>a. You must give any other recipients of the Work or Derivative Works a copy of this License; and</p> <p>b. You must cause any modified files to carry prominent notices stating that You changed the files; and</p> <p>c. You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and</p> <p>d. If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"getting-started/","title":"iMX RT1011 Nano Kit Quick Start Guide","text":""},{"location":"getting-started/#introduction","title":"Introduction","text":"<p>This guide provides a quick introduction to running the Out-of-Box Demo for iMX RT1011 Nano Kit. The Out-of-Box Demo blinks the Red LED forever and prints logs to the console over USB.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"getting-started/#flashing-the-demo-optional","title":"Flashing the Demo (Optional)","text":"<p>iMX RT1011 Nano Kit is shipped with the UF2 Bootloader and led blinky demo. If the firmware is not present, follow the steps below to flash the demo:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Download the demo firmware. Drag and drop <code>blinky.uf2</code> onto the UF2BOOT volume.</li> <li>After the firmware is done flashing, the demo will start running. If not, try to click the RST button to reset the board.</li> </ol> <p>Ensure UF2 Bootloader is present</p> <p>If the UF2 Bootloader is not present or gets corrupted somehow, you can re-install the UF2 Bootloader by following the UF2 Bootloader Installation section.</p>"},{"location":"getting-started/#running-the-demo","title":"Running the Demo","text":"<p>Now, you can run the demo by following the steps below:</p> <ol> <li>Connect the board to your computer using the USB-C Cable.</li> <li> <p>When the board is powered, the Green LED should stay on and the Red LED should flash on and off.</p> <p></p> </li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\n...\n</code></pre> </li> </ol>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Congratulations! You have finished the iMX RT1011 Nano Kit quick start guide. Want to learn more? Check out the following pages:</p> <ul> <li> <p>Programming with UF2 Bootloader</p> <p>Learn how to install UF2 Bootloader on iMX RT1011 Nano Kit and flash the application code in UF2.</p> <p> Learn more</p> </li> <li> <p>MCUXpresso Secure Provisioning Tool</p> <p>Learn how to use MCUXpresso Secure Provisioning Tool to prepare and flash images.</p> <p> Learn more</p> </li> <li> <p>Develop with Zephyr RTOS</p> <p>Learn how to get started with Zephyr RTOS on iMX RT1011 Nano Kit and explore some of the typical samples.</p> <p> Getting started</p> </li> <li> <p>Code in Python</p> <p>Get started with CircuitPython on iMX RT1011 Nano Kit and explore some of the typical samples in Python.</p> <p> Getting started</p> </li> </ul>"},{"location":"hardware/","title":"Hardware description","text":"<p>This section of the documentation specifies and describes the iMX RT1011 Nano Kit mainly from a hardware point of view.</p>"},{"location":"hardware/#hardware-diagram","title":"Hardware diagram","text":"<p>The following figure illustrates the iMX RT1011 Nano Kit hardware diagram. The design is available with loose or pre-soldered pin headers.</p> <p></p>"},{"location":"hardware/#mechanical-dimensions","title":"Mechanical dimensions","text":"<p>iMX RT1011 Nano Kit is a single sided 55.88mm x 20.32mm (2.2\" x 0.8\") 1mm thick PCB with a USB Type-C port and dual castellated/through-hole pins.</p> <p></p>"},{"location":"hardware/#power-supply","title":"Power supply","text":"<p>iMX RT1011 Nano Kit can be powered by either the USB-C port or alternatively VSYS pin with wide input voltage range (1.8-5.5V). An on-board buck-boost converter (TPS63802) provides 3V3 to the MIMXRT1011 MCU and all other peripherals.</p> <p>The following figure illustrates the power supply circuitry:</p> <p></p> <p>VBUS is the 5V input from the USB-C port. There are two parallel Schottky diodes between VBUS and VSYS, which add flexibility by allowing power ORing of different supplies into VSYS.</p> <p>Set 3V3_EN <code>HIGH</code> to enable 3V3 output and <code>LOW</code> to disable 3V3 output. This pin has a pull-up resistor (100KOhm) and can be tied to GND to place the board in Power-Down mode.</p> <p>Set MODE <code>LOW</code> for power save mode and <code>HIGH</code> for forced PWM mode. This pin is tied to <code>GPIO_SD_13</code> with a pull-down resistor (100KOhm).</p> <p>How to power the board?</p> <p>iMX RT1011 Nano Kit has simple and flexible power management with various options for easily powering the board from USB-C, external supplies or batteries.</p> Using USB-C portFeeding VSYS directlyFeeding VSYS via a Schottky diodeFeeding VSYS via a P-MOSFETUsing a battery charger <p>This is the simplest way to power the board, which will power VSYS (and therefore the system) from the 5V USB VBUS voltage, through two internal Schottky diodes (so VSYS becomes VBUS minus the Schottky diode forward voltage).</p> <p></p> <p>If the USB-C port is NOT going to be used, it is safe to power the board by directly connecting VSYS to your preferred power source (in the range 1.8V to 5.5V).</p> <p></p> <p>To safely add a second power source to the board, simply feed VSYS through an external Schottky diode.</p> <p></p> <p>An improved way to power from a second source is using an external P-MOSFET to replace the Schottky diode as shown in the following figure.</p> <p></p> <p>iMX RT1011 Nano Kit can be also used with a battery charger with power path manager which will automatically and seamlessly switch between the input source and the battery power.</p> <p></p>"},{"location":"hardware/#general-purpose-ios","title":"General purpose I/Os","text":"<p>iMX RT1011 Nano Kit has up to 33 multi-function General Purpose I/Os (<code>A0</code>~<code>A14</code> can be used as ADC inputs) available on the header pins. These GPIOs are powered from the on-board 3.3V rail, and should be used for 3.3V logic level.</p> <p>The following figure illustrates the GPIOs pinout:</p> <p></p>"},{"location":"hardware/#buttons-and-leds","title":"Buttons and LEDs","text":"<p>iMX RT1011 Nano Kit has two buttons - RST button and USR/BT button:</p> <ul> <li>RST button: Used to reset the iMXRT1011 MCU.</li> <li>USR/BT button: Used for user input or Boot Mode trigger.</li> </ul> <p>The Green LED is used for USB power indicating and the Red LED is controlled by <code>GPIO_SD_4</code>.</p> <p>The following table shows the Buttons and LEDs connections:</p> Part GPIO Description RST Button <code>NC</code> Press to reset the MCU USR/BT Button <code>GPIO_SD_3</code> Hold while powering up to enter Serial Downloader on ROM. Pull <code>GPIO_SD_3</code> LOW when pressed at normal mode Green LED <code>NC</code> Indicate USB power Red LED <code>GPIO_SD_4</code> Set <code>GPIO_SD_4</code> HIGH/LOW to turn on/off the LED"},{"location":"hardware/#external-memory","title":"External memory","text":"<p>iMX RT1011 Nano Kit has 128 Mbit QSPI Flash (W25Q128JV) with XIP support and on-the-fly decryption for firmware and disk storage. The memory is connected to the MIMXRT1011 MCU using FlexSPI:</p> FlexSPI W25Q128JV Pin <code>GPIO_SD_6</code> <code>CS#</code> <code>GPIO_SD_10</code> <code>SCLK</code> <code>GPIO_SD_9</code> <code>SIO0/SI</code> <code>GPIO_SD_7</code> <code>SIO1/SO</code> <code>GPIO_SD_8</code> <code>SIO2/WP#</code> <code>GPIO_SD_11</code> <code>SIO3/HOLD#</code>"},{"location":"hardware/#boot-mode-configurations","title":"Boot mode configurations","text":"<p>iMX RT1011 Nano Kit has two boot modes. The boot mode is selected based on the binary value stored in the internal BOOT_MODE register. USR/BT button is used to select the boot mode on the iMX RT1011 Nano Kit.</p> <p>The following table shows the Boot Mode Configurations:</p> MODE USR/BT Button BOOT_MODE[1:0] Internal Boot Released <code>0b10</code> Serial Downloader Pressed while powering up <code>0b01</code>"},{"location":"hardware/#debug-interface","title":"Debug interface","text":"<p>iMX RT1011 Nano Kit supports Arm Serial Wire Debug (SWD) port, which makes it possible to connect external debuggers for debugging and programming. The I/O voltage of SWD should be 3.3V.</p> <p>The following figure demonstrates how to connect an external debugger (for example, Pitaya-Link debug probe) for debugging:</p> <p></p> <p>The connections are listed in the table below:</p> Debugger Wire iMX RT1011 Nano Kit <code>3V3</code> <code>VSYS</code> <code>GND</code> <code>GND</code> <code>RESET</code> <code>RESET</code> <code>SWDCLK</code> <code>SWDCLK</code> <code>SWDIO</code> <code>SWDIO</code>"},{"location":"introduction/","title":"iMX RT1011 Nano KitHigh-performance microcontroller board operating up to 500MHz, built around NXP iMX RT1011","text":""},{"location":"introduction/#introduction","title":"Introduction","text":"<p>iMX RT1011 Nano Kit is a small, high-performing prototyping kit designed around NXP's iMX RT1011 Crossover MCU based on the Arm Cortex-M7 core, which operates at speeds up to 500 MHz to provide high CPU performance and best real-time response. It has 128 KB on-chip RAM that can be flexibly configured as TCM or general-purpose as well as numerous peripherals including high speed USB, UART, SPI, I2C, SAI, PWM, GPIO, ADC and etc to support a wide range of applications.</p> <p>The design provides external 128 Mbit QSPI flash with XIP support, flexible power management, programmable LED and Button, easy-to-use form factor with USB-C and dual-row 40 pins in DIP/SMT type, including up to 33 multi-function GPIO pins (15 can be configured as ADC inputs) and Serial Wire Debug (SWD) port. Available with loose or pre-soldered headers, for even more flexibility in your projects.</p> <p>It's shipped with UF2 Bootloader for easy firmware update. Zephyr RTOS and Python are supported as well for rapid prototyping.</p> <p></p>"},{"location":"introduction/#key-features","title":"Key Features","text":"<ul> <li> <p>NXP's MIMXRT1011DAE5A Crossover MCU</p> <ul> <li>Arm\u00ae Cortex-M7 @ 500MHz</li> <li>On-chip RAM size up to 128 KB shared with CM7 TCM</li> <li>Boot ROM (64 KB)</li> <li>High speed USB, UART, SPI, I2C, SAI, PWM, GPIO, ADC support</li> </ul> </li> <li> <p>128 Mb QSPI Flash with XIP support and on-the-fly decryption</p> </li> <li>User programmable Button and LED</li> <li>Up to 33 multi-function General Purpose IOs (15 can be used as ADC inputs)</li> <li>Arm Serial Wire Debug (SWD) port via edge pins</li> <li>Flexible power management with various options for easily powering the unit</li> <li>Wide input voltage range: 1.8 V to 5.5 V, output 3.3V and up to 2A when Input \u2265 2.3 V</li> <li>3.3V IO Operating Voltage</li> <li>Dual-row 40 pins 55.88mm x 20.32mm (2.2\" x 0.8\") DIP/SMT form factor</li> <li>Reversible USB-C connector</li> <li>Available with loose or pre-soldered headers</li> <li>Shipped with UF2 Bootloader supporting Drag-and-drop programming over USB drive</li> <li>Easy to enter Boot ROM Serial Downloader even when the UF2 Bootloader gets corrupted</li> <li>Built on open source, supporting Zephyr RTOS, Python, etc</li> </ul>"},{"location":"introduction/#hardware-diagram","title":"Hardware Diagram","text":"<p>The following figure illustrates the iMX RT1011 Nano Kit hardware diagram. The design is available with loose or pre-soldered pin headers. For more details, refer to the Hardware description section.</p> <p></p>"},{"location":"introduction/#whats-in-the-box","title":"What's in the box","text":"Part Quantity iMX RT1011 Nano Kit board 1 20 Pin 2.54mm THT Pin Header(Loose or Pre-soldered) 2"},{"location":"purchase/","title":"Purchase","text":""},{"location":"purchase/#buy-online","title":"Buy Online","text":"<p>iMX RT1011 Nano Kit is available on the following channels (click to go directly to the product):</p> <p> </p>"},{"location":"purchase/#request-large-volume-pricing","title":"Request Large Volume Pricing","text":"<p>Thank you for your interest in purchasing large volume from Makerdiary. In order to help you more efficiently, please contact our sales: store@makerdiary.com</p> <p>Request Quote</p>"},{"location":"purchase/#design-customization","title":"Design &amp; Customization","text":"<p>We are ready to customize our hardware and firmware to better meet your solution's needs. Many of our platforms are prepared for customization.</p> <p>If you would like to do some serious business, feel free to contact us and we'll reply before you know it: support@makerdiary.com</p> <p>Design Services</p>"},{"location":"revision-history/","title":"Revision history","text":""},{"location":"revision-history/#hardware","title":"Hardware","text":""},{"location":"revision-history/#REVA","title":"Rev.A December 25, 2023","text":"<ul> <li>The first public release</li> </ul>"},{"location":"revision-history/#software-documentation","title":"Software &amp; Documentation","text":""},{"location":"revision-history/#DOC_V1.0.0","title":"V1.0.0 Sep 17, 2024","text":"<ul> <li>The first public release</li> </ul>"},{"location":"blog/","title":"Latest posts","text":""},{"location":"blog/circuitpython-on-imx-rt1011-nano-kit/","title":"CircuitPython on iMX RT1011 Nano Kit","text":""},{"location":"blog/circuitpython-on-imx-rt1011-nano-kit/#what-is-circuitpython","title":"What is CircuitPython?","text":"<p>CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. It makes getting started easier than ever with no upfront desktop downloads needed. Once you get your board set up, open any text editor, and get started editing code. It's that simple.</p> <p>CircuitPython is an implementation of Python, which is a high-level programming language which means it's designed to be easier to read, write and maintain. It supports modules and packages which means it's easy to reuse your code for other projects. It has a built in interpreter which means there are no extra steps, like compiling, to get your code to work. And of course, it is Open Source Software which means it's free for anyone to use, modify or improve upon.</p>"},{"location":"blog/circuitpython-on-imx-rt1011-nano-kit/#why-circuitpython","title":"Why CircuitPython?","text":"<p>CircuitPython is a fork of MicroPython, and offers unified Python core APIs and a growing list of 300+ device libraries and drivers that work with it. You can see differences from MicroPython.</p> <p>Here is some reasons to use CircuitPython:</p> <ul> <li>You want to get up and running quickly. Create a file, edit your code, save the file, and it runs immediately. There is no compiling, no downloading and no uploading needed.</li> <li>You're new to programming. CircuitPython is designed with education in mind. It's easy to start learning how to program and you get immediate feedback from the board.</li> <li>Easily update your code. Since your code lives on the disk drive, you can edit it whenever you like, you can also keep multiple files around for easy experimentation.</li> <li>The serial console and REPL. These allow for live feedback from your code and interactive programming.</li> <li>File storage. The internal storage for CircuitPython makes it great for data-logging, playing audio clips, and otherwise interacting with files.</li> <li>Strong hardware support. CircuitPython has builtin support for microcontroller hardware features like digital I/O pins, hardware buses (UART, I2C, SPI), audio I/O, and other capabilities. There are also many libraries and drivers for sensors, breakout boards and other external components.</li> <li>It's Python! Python is the fastest-growing programming language. It's taught in schools and universities. CircuitPython is almost-completely compatible with Python. It simply adds hardware support.</li> </ul>"},{"location":"blog/circuitpython-on-imx-rt1011-nano-kit/#how-to-get-started","title":"How to get started?","text":"<p>To use CircuitPython, you need to choose a microcontroller board well supported by CircuitPython. There are 300+ boards that can run CircuitPython.</p> <p>Here we have ported CircuitPython to our brand new iMX RT1011 Nano Kit and offer an extensive set of documentation and samples to help you get started quickly:</p> <ul> <li> <p>Getting started with CircuitPython</p> <p>Take you through getting up and running with CircuitPython.</p> <p> Learn more</p> </li> <li> <p>More samples</p> <p>Explore more samples running on iMX RT1011 Nano Kit.</p> <p> Learn more</p> </li> <li> <p>Reference</p> <p>A variety of modules reference that can be used in your sample applications.</p> <p> Explore more</p> </li> </ul>"},{"location":"blog/imx-rt1011-nano-kit-is-here/","title":"iMX RT1011 Nano Kit is Here!","text":""},{"location":"blog/imx-rt1011-nano-kit-is-here/#overview","title":"Overview","text":"<p>We are excited to announce the iMX RT1011 Nano Kit, a small and high-performing prototyping kit designed around NXP's iMX RT1011 Crossover MCU based on the Arm Cortex-M7 core, which operates at speeds up to 500 MHz to provide high CPU performance and best real-time response.</p> <p>iMX RT1011 Nano Kit comes in the same form factor we first introduced in our nRF52840 Connect Kit, and provides external 128 Mbit QSPI flash with XIP support, flexible power management, programmable LED and Button, up to 33 multi-function GPIO pins (15 can be configured as ADC inputs) and Serial Wire Debug (SWD) port.</p> <p></p>"},{"location":"blog/imx-rt1011-nano-kit-is-here/#imx-rt1011-crossover-mcu","title":"iMX RT1011 Crossover MCU","text":"<p>The iMX RT1011 is a member of NXP's iMX RT real-time processor family based on the Arm\u00ae Cortex\u00ae-M7 core, which operates at speeds up to 500 MHz to provide high CPU performance and best real-time response. It has 128 KB on-chip RAM that can be flexibly configured as TCM or general-purpose as well as numerous peripherals including high speed USB, UART, SPI, I2C, SAI, PWM, GPIO, ADC and etc to support a wide range of applications.</p> <p></p>"},{"location":"blog/imx-rt1011-nano-kit-is-here/#easy-firmware-update","title":"Easy firmware update","text":"<p>iMX RT1011 Nano Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive.</p> <p>In addition, you can always enter the ROM Serial Downloader even when the UF2 Bootloader gets corrupted somehow and use the MCUXpresso Secure Provisioning Tool to build and write the images to the board.</p>"},{"location":"blog/imx-rt1011-nano-kit-is-here/#zephyr-rtos-support","title":"Zephyr RTOS support","text":"<p>The Zephyr Project is a Linux Foundation hosted Collaboration Project. It\u2019s an open-source collaborative effort uniting developers and users in building a best-in-class small, scalable real\u2043time operating system (RTOS) optimized for resource-constrained devices, across multiple architectures.</p> <p>Zephyr RTOS support is available on iMX RT1011 Nano Kit. To quickly get started with the Zephyr RTOS application development, refer to our Develop with Zephyr RTOS guide.</p>"},{"location":"blog/imx-rt1011-nano-kit-is-here/#circuitpython-support","title":"CircuitPython support","text":"<p>Python is a high-level programming language which means it's designed to be easier to read, write and maintain. It has a built-in interpreter which means there are no extra steps, like compiling, to get your code to work.</p> <p>iMX RT1011 Nano Kit can run CircuitPython which allows you to access hardware-specific functionality and peripherals with Python programming language. With CircuitPython, there are no upfront desktop downloads needed. Once you get your board set up, open any text editor, and start editing code. It's that simple. To get started with CircuitPython, check our Code in Python guide.</p>"},{"location":"blog/imx-rt1011-nano-kit-is-here/#get-involved","title":"Get Involved","text":"<p>Interested in our brand new iMX RT1011 Nano Kit? You can get it from the official store or refer to our wiki page for more technical resources.</p>"},{"location":"blog/introducing-zephyr-rtos/","title":"Introducing Zephyr RTOS","text":""},{"location":"blog/introducing-zephyr-rtos/#what-is-zephyr","title":"What Is Zephyr?","text":"<p>The Zephyr\u2122 Project is a scalable RTOS, which supports multiple hardware architectures, optimized for resource-constrained devices, and built with security in mind. It is based on a small-footprint kernel designed for use on resource-constrained systems.</p> <p>NXP, as one of the six founding member of The Zephyr\u2122 Project, actively contributes to the Zephyr community. All the i.MX RT crossover MCUs have support in the Zephyr source tree which are actively maintained. Developers are able to tailor a solution easily to meet their needs using a true open source project with hardware, developer tools, and sensor and device drivers. Security enhancements with Zephyr OS enable easy implementation of device management, connectivity stacks, and file systems.</p> <p>For more details on the Zephyr RTOS, visit www.zephyrproject.org/.</p>"},{"location":"blog/introducing-zephyr-rtos/#key-features-of-zephyr","title":"Key Features of Zephyr","text":"<p>Zephyr has several important features that contribute to its real-time development appeal and its adoption in embedded systems and connected devices:</p> <ul> <li>Open source: Zephyr is an open source project that promotes collaboration and allows developers to freely access, modify, and contribute code.</li> <li>Modular architecture: Zephyr\u2019s modular architecture gives developers the flexibility to select and include only what is necessary from existing Zephyr components or to develop and include new components to create an optimized footprint for built-for-purpose RTOS implementation.</li> <li>Scalability: Zephyr is scalable across a wide range of devices with different hardware capabilities, from small sensor nodes to powerful IoT gateways.</li> <li>Cross-architecture support: Zephyr has broad hardware support that includes various architectures, such as Arm, x86, and RISC-V, making it compatible with a spectrum of hardware platforms. This simplifies development and promotes interoperability.</li> <li>Real-time capabilities: Zephyr provides real-time capabilities to applications that require the precise timing and responsiveness often necessary in industrial automation, healthcare, and automotive use cases.</li> <li>Libraries and protocols: The Zephyr Project includes a comprehensive set of libraries, protocols, and device drivers. These resources simplify development, enabling developers to build real-time and embedded applications without having to start from scratch.</li> <li>Security focus: Zephyr provides features such as memory protection, access controls, and secure boot options. This focus on security is crucial for embedded applications that demand data integrity and user privacy.</li> <li>Community support: Zephyr is supported by a growing and active community of developers and contributors with real-time and embedded systems expertise.</li> </ul>"},{"location":"blog/introducing-zephyr-rtos/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. An extensive set of guides are available to take you through the basics of Zephyr application development on iMX RT1011 Nano Kit.</p> <ul> <li> <p>Setting up the environment</p> <p>Learn how to set up a command-line Zephyr development environment.</p> <p> Learn more</p> </li> <li> <p>Building and running the first sample</p> <p>Learn how to build and run the first sample Blinky.</p> <p> Learn more</p> </li> <li> <p>More samples</p> <p>Explore more samples running on iMX RT1011 Nano Kit.</p> <p> Explore more</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We're really glad you're reading this, because we would love to have more developers contribute to this project! If you're passionate about making this project better, you're in the right place.</p>"},{"location":"contributing/#before-contributing","title":"Before contributing","text":"<p>If you encounter a bug or think of a useful feature, please create a new issue. Creating an issue before jumping into code ensures we can discuss it and determine whether it aligns with the direction of this project.</p> <p>If you want to contribute to the project, regardless of whether it's a small bug fix or correcting a typo, please feel free to do so. Any help goes a long way! Also, contributions aren't necessarily all code related. Other contributions can be in the form of issues, pull requests, discussions, etc.</p>"},{"location":"contributing/#got-a-question-or-problem","title":"Got a question or problem?","text":"<p>For quick questions there's no need to open an issue as you can reach us on GitHub Discussions.</p>"},{"location":"contributing/#reporting-a-bug","title":"Reporting a bug","text":"<p>Bugs are tracked as GitHub issues. Search open issues to see if someone else has reported a similar bug. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p> <p>When creating a new issue, please ensure the issue is clear and include additional details to help maintainers reproduce it:</p> <ul> <li>Use a clear and descriptive title for the issue to identify the problem.</li> <li>Describe the exact steps which reproduce the problem in as many details as possible.</li> <li>Provide specific examples to demonstrate the steps. Include links to files, or copy/pasteable snippets. If you're providing snippets in the issue, use Markdown code blocks.</li> <li>Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior.</li> <li>Explain which behavior you expected to see instead and why.</li> <li>Include screenshots and animated GIFs where possible.</li> </ul>"},{"location":"contributing/#sign-off-your-commits","title":"Sign-off your commits","text":"<p>A sign-off message in the following format is required on each commit in the pull request:</p> <pre><code>This is my commit message\n\nSigned-off-by: First_Name Last_Name &lt;My_Name@example.com&gt;\n</code></pre> <p>The text can either be manually added to your commit body, or you can add either <code>-s</code> or <code>--signoff</code> to your usual git commit commands.</p>"},{"location":"contributing/#creating-your-signoff","title":"Creating your signoff","text":"<p>Git has a <code>-s | --signoff</code> command-line option to append this automatically to your commit message:</p> <pre><code>git commit --signoff --message 'This is my commit message'\n</code></pre> <p>or</p> <pre><code>git commit -s -m \"This is my commit message\"\n</code></pre> <p>This will use your default git configuration which is found in <code>.git/config</code> and usually, it is the <code>username systemaddress</code> of the machine which you are using.</p> <p>To change this, you can use the following commands (Note these only change the current repo settings, you will need to add <code>--global</code> for these commands to change the installation default).</p> <p>Your name:</p> <pre><code>git config user.name \"First_Name Last_Name\"\n</code></pre> <p>Your email:</p> <pre><code>git config user.email \"My_Name@example.com\"\n</code></pre>"},{"location":"contributing/#how-to-amend-a-sign-off","title":"How to amend a sign-off","text":"<p>If you have authored a commit that is missing the signed-off-by line, you can amend your commits and push them to GitHub</p> <pre><code>git commit --amend --signoff\n</code></pre> <p>If you've pushed your changes to GitHub already you'll need to force push your branch after this with <code>git push -f</code>.</p>"},{"location":"guides/python/","title":"Code in Python","text":""},{"location":"guides/python/#introduction","title":"Introduction","text":"<p>Python is a high-level programming language which means it's designed to be easier to read, write and maintain. It has a built-in interpreter which means there are no extra steps, like compiling, to get your code to work.</p> <p>iMX RT1011 Nano Kit can run CircuitPython which allows you to access hardware-specific functionality and peripherals in the popular Python programming language. With CircuitPython, there are no upfront desktop downloads needed. Once you get your board set up, open any text editor, and start editing code. It's that simple.</p> <p>Why CircuitPython?</p> <p>CircuitPython is based on MicroPython and features unified Python core APIs and a growing list of 300+ device libraries and drivers that work with it. See differences from MicroPython.</p>"},{"location":"guides/python/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. And to help you get started, we have provided an extensive set of documentation. Find the details below:</p> <ul> <li> <p>Getting started with CircuitPython</p> <p>Take you through getting up and running with CircuitPython.</p> <p> Learn more</p> </li> <li> <p>More samples</p> <p>Explore more samples running on iMX RT1011 Nano Kit.</p> <p> Learn more</p> </li> <li> <p>Reference</p> <p>A variety of modules reference that can be used in your sample applications.</p> <p> Explore more</p> </li> </ul>"},{"location":"guides/python/getting-started/","title":"Getting started with CircuitPython","text":"<p>This section of the documentation takes you through getting up and running with CircuitPython on iMX RT1011 Nano Kit.</p>"},{"location":"guides/python/getting-started/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul> <p>Ensure UF2 Bootloader is present</p> <p>CircuitPython requires the UF2 Bootloader running on the board. If the UF2 Bootloader is not present or gets corrupted somehow, you can re-install the UF2 Bootloader by following the UF2 Bootloader Installation section.</p>"},{"location":"guides/python/getting-started/#installing-circuitpython","title":"Installing CircuitPython","text":"<p>The pre-built CircuitPython firmware in <code>.uf2</code>-format is located in <code>firmware/circuitpython/</code>.</p> <p>Download the latest firmware and complete the following steps to flash the firmware:</p> <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST/BT button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>circuitpython-imxrt1011_nanokit-en_US-&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The Red LED blinks fast during flashing.</li> <li>CircuitPython will start running after flashing. It will mount as a Mass Storage Device called CIRCUITPY.</li> </ol> <p></p>"},{"location":"guides/python/getting-started/#coding-with-mu-editor","title":"Coding with Mu Editor","text":"<p>Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page, choose your operating system and follow the instructions to install the latest Mu Editor.</p> <p>Start Mu Editor, click Mode on Top Menu. You will be prompted to Select Mode. Select CircuitPython and click OK.</p> <p></p> <p>In the text editor, try some Python code:</p> <pre><code>print('Hello, CircuitPython!')\n</code></pre> <p>Click Save on Top Menu. A window will appear. Give the name <code>code.py</code> for your code and save it onto the CIRCUITPY drive. Your code will run as soon as the file is done saving.</p> <p>Click Serial on Top Menu to open a serial data connection to the board. This will result in a new pane between the text editor and Mu\u2019s footer, which prints the data from the board. </p> <p></p>"},{"location":"guides/python/getting-started/#using-circuitpython-repl","title":"Using CircuitPython REPL","text":"<p>The CircuitPython REPL (Read-Evaluate-Print-Loop) allows you to enter individual lines of code and have them run immediately. It's really handy if you're running into trouble with a particular program and can't figure out why. It's interactive so it's great for testing new ideas.</p> <p>To use the REPL, you first need to be connected to the serial console. Here are the common ways you can use to establish a serial connection:</p> Using Mu EditorRunning <code>screen</code>Using PuTTY <p>Mu Editor has a Serial Console, which can be used to interact with CircuitPython REPL.</p> <p>Click Serial on the Mu Editor's Top Menu to open a serial data connection to the board. This will result in a new pane between the text editor and Mu\u2019s footer: </p> <pre><code>Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nHello, CircuitPython!\n\nCode done running.\n\nPress any key to enter the REPL. Use CTRL-D to reload.\n</code></pre> <p>On macOS/Linux, you can open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Where <code>&lt;serial-port-name&gt;</code> is the correct serial port that your computer uses to communicate with the board.</p> <p>On Windows, you can use PuTTY to interact with CircuitPython REPL. </p> <p>Start PuTTY, configure the correct serial port and click Open:</p> <p></p> <p>Where <code>&lt;serial-port-name&gt;</code> is the correct serial port that your computer uses to communicate with the board.</p> <p>Once that connection has been established, type CTRL + C to drop into the REPL.</p> <p>Try to write some Python code in the REPL, then press Enter :</p> <pre><code>&gt;&gt;&gt; print('Hello, CircuitPython!')\n&gt;&gt;&gt; Hello, CircuitPython!\n</code></pre> <p>Return to the Serial Console</p> <p>When you're ready to leave the REPL and return to the serial console, simply press CTRL + D . This will reload your board and reenter the serial console. You will restart the program you had running before entering the REPL.</p>"},{"location":"guides/python/reference/","title":"Reference","text":"<p>CircuitPython provides a variety of modules that can be used in your sample applications.</p> <p>Here you can find documentation for these modules, including API reference.</p> Module Description <code>_bleio</code> Bluetooth Low Energy (BLE) communication <code>_pixelmap</code> A fast pixel mapping library <code>adafruit_ble</code> Higher-level Bluetooth Low Energy functionality, building on the native <code>_bleio</code> module <code>adafruit_bus_device</code> Hardware accelerated external bus access <code>adafruit_hid</code> USB Human Interface Device (HID) class <code>adafruit_pixelbuf</code> A fast RGB(W) pixel buffer library for like NeoPixel and DotStar <code>aesio</code> AES encryption routines <code>alarm</code> Alarms and sleep <code>analogio</code> Analog hardware support <code>array</code> Arrays of numeric data <code>atexit</code> Atexit Module <code>audiobusio</code> Support for audio input and output over digital buses <code>audiocore</code> Support for audio samples <code>audiomixer</code> Support for audio mixing <code>audiomp3</code> Support for MP3-compressed audio files <code>audiopwmio</code> Audio output via digital PWM <code>binascii</code> Binary/ASCII conversions <code>bitbangio</code> Digital protocols implemented by the CPU <code>bitmapfilter</code> Convolve an image with a kernel <code>bitmaptools</code> Collection of bitmap manipulation tools <code>board</code> Board specific pin names <code>builtins</code> Builtin functions and exceptions <code>busdisplay</code> Displays a <code>displayio</code> object tree on an external device with a built-in framebuffer <code>busio</code> Hardware accelerated external bus access <code>codeop</code> Utilities to compile possibly incomplete Python source code <code>collections</code> Collection and container types <code>countio</code> Support for edge counting <code>digitalio</code> Basic digital pin support <code>displayio</code> Native helpers for driving displays <code>epaperdisplay</code> Displays a <code>displayio</code> object tree on an e-paper display <code>errno</code> System error codes <code>fontio</code> Core font related data structures <code>fourwire</code> Connects to a BusDisplay over a four wire bus <code>framebufferio</code> Native framebuffer display driving <code>gc</code> Control the garbage collector <code>getpass</code> Getpass Module <code>gifio</code> Access GIF-format images <code>i2cdisplaybus</code> Communicates to a display IC over I2C <code>io</code> Input/output streams <code>jpegio</code> Support for JPEG image decoding <code>json</code> JSON encoding and decoding <code>keypad</code> Support for scanning keys and key matrices <code>keypad_demux</code> Support for scanning key matrices that use a demultiplexer <code>locale</code> Locale support module <code>math</code> Mathematical functions <code>microcontroller</code> Pin references and cpu functionality <code>micropython</code> Access and control MicroPython internals <code>msgpack</code> Pack object in msgpack format <code>neopixel</code> Higher level NeoPixel driver that presents the strip as a sequence <code>neopixel_write</code> Low-level neopixel implementation <code>nvm</code> Non-volatile memory <code>onewireio</code> Low-level bit primitives for Maxim (formerly Dallas Semi) one-wire protocol <code>os</code> Functions that an OS normally provides <code>pwmio</code> Support for PWM based protocols <code>rainbowio</code> Rainbowio Module <code>random</code> Pseudo-random numbers and choices <code>re</code> Simple regular expressions <code>rotaryio</code> Support for reading rotation sensors <code>rtc</code> Real Time Clock <code>sdcardio</code> Interface to an SD card via the SPI bus <code>select</code> Wait for events on a set of streams <code>sharpdisplay</code> Support for Sharp Memory Display framebuffers <code>storage</code> Storage management <code>struct</code> Manipulation of C-style data <code>supervisor</code> Supervisor settings <code>synthio</code> Support for MIDI synthesis <code>sys</code> System specific functions <code>terminalio</code> Displays text in a TileGrid <code>time</code> Time and timing related functions <code>touchio</code> Touch related IO <code>traceback</code> Traceback Module <code>ulab</code> Manipulate numeric data similar to numpy <code>usb_cdc</code> USB CDC Serial streams <code>usb_hid</code> USB Human Interface Device <code>usb_midi</code> MIDI over USB <code>vectorio</code> Lightweight 2D shapes for displays <code>watchdog</code> Watchdog Timer <code>zlib</code> zlib decompression functionality"},{"location":"guides/python/samples/","title":"Samples","text":"<p>We think the best way to learn is by doing. A set of samples are provided in the imxrt1011-nanokit repository.</p> <ul> <li>Blinky \u2013 Blink an LED forever using the <code>digitalio</code> module</li> <li>Button \u2013 Demonstrate the use of GPIO input using the <code>digitalio</code> module</li> <li>ADC \u2013 Demonstrate the use of the <code>analogio</code> module</li> <li>CPU Temperature \u2013 Demonstrate the use of the on-chip Temperature sensor</li> <li>PWM \u2013 Demonstrate the use of the <code>pwmio</code> module</li> <li>USB HID Keyboard \u2013 Demonstrate the HID Keyboard implementation</li> <li>USB HID Mouse \u2013 Demonstrate the HID Mouse implementation</li> </ul>"},{"location":"guides/python/samples/adc/","title":"ADC","text":"<p>The ADC sample demonstrates using the <code>analogio</code> module to measure the voltage of the A0 pin.</p>"},{"location":"guides/python/samples/adc/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/adc/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nfrom analogio import AnalogIn\n\n# Analog In \nanalog_in = AnalogIn(board.A0)\n\n# Convert ADC value to voltage in mV\ndef get_voltage(ain):\n    return (ain.value * 3300) / 65536\n\nwhile True:\n    print((get_voltage(analog_in),))\n    time.sleep(0.1)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Click Serial on Mu Editor's Top Menu to open a serial console. You should see the console output, similar to what is shown in the following:</p> <pre><code>Code stopped by auto-reload. Reloading soon.\n\nAuto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\n(30.6152,)\n(32.2266,)\n(33.0322,)\n(32.2266,)\n(31.4209,)\n(30.6152,)\n(29.8096,)\n(31.4209,)\n(32.2266,)\n(33.0322,)\n...\n</code></pre> </li> <li> <p>You can also use the plotter for data inspection. Click Plotter on Mu Editor's Top Menu to open up a plotter pane:</p> <p></p> </li> </ol>"},{"location":"guides/python/samples/blinky/","title":"Blinky","text":""},{"location":"guides/python/samples/blinky/#overview","title":"Overview","text":"<p>The Blinky sample is a simple application which blinks an LED forever using the <code>digitalio</code> module. The source code shows how to configure the LED, then turn it on and off.</p>"},{"location":"guides/python/samples/blinky/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/blinky/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport digitalio\nimport board\n\n# Red LED\nled = digitalio.DigitalInOut(board.LED)\nled.direction = digitalio.Direction.OUTPUT\nwhile True:\n    led.value = True\n    time.sleep(0.1)\n    led.value = False\n    time.sleep(0.1)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Observe that the Red LED starts to blink.</p> </li> </ol>"},{"location":"guides/python/samples/button/","title":"Button","text":""},{"location":"guides/python/samples/button/#overview","title":"Overview","text":"<p>The Button sample demonstrates the use of GPIO input using the <code>digitalio</code> module. It prints a message to the console each time the state of the button changes.</p>"},{"location":"guides/python/samples/button/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/button/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import board\nimport digitalio\n\n# User Button\nbutton = digitalio.DigitalInOut(board.USR_BTN)\nbutton.direction = digitalio.Direction.INPUT\nbutton.pull = digitalio.Pull.DOWN\n\nlast_value = button.value\n\nwhile True:\n    if last_value != button.value:\n        last_value = button.value\n        print('Button is ' + ('released' if button.value else 'pressed'))\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Click Serial on Mu Editor's Top Menu to open a serial console. Observe the output of the console and press the USR/BT button. You should see the output, similar to what is shown in the following:</p> <pre><code>Code stopped by auto-reload. Reloading soon.\n\nAuto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nButton is pressed\nButton is released\nButton is pressed\nButton is released\n...\n</code></pre> </li> </ol>"},{"location":"guides/python/samples/cpu_temperature/","title":"CPU Temperature","text":"<p>The CPU Temperature sample demonstrates how to use the on-chip Temperature sensor to measure the internal die temperature.</p>"},{"location":"guides/python/samples/cpu_temperature/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/cpu_temperature/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport microcontroller\n\nwhile True:\n    print((microcontroller.cpu.temperature,))\n    time.sleep(0.1)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Click Serial on Mu Editor's Top Menu to open a serial console. You should see the console output, similar to what is shown in the following:</p> <pre><code>Code stopped by auto-reload. Reloading soon.\n\nAuto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\n(38.5484,)\n(38.5484,)\n(38.5484,)\n(39.1129,)\n(38.5484,)\n(38.5484,)\n(39.1129,)\n(39.1129,)\n(38.5484,)\n(39.1129,)\n...\n</code></pre> </li> <li> <p>You can also use the plotter for data inspection. Click Plotter on Mu Editor's Top Menu to open up a plotter pane:</p> <p></p> </li> </ol>"},{"location":"guides/python/samples/pwm/","title":"PWM","text":""},{"location":"guides/python/samples/pwm/#overview","title":"Overview","text":"<p>The PWM sample demonstrates using the <code>pwmio</code> module to fade the Red LED (alias <code>LED</code>) on iMX RT1011 Nano Kit.</p>"},{"location":"guides/python/samples/pwm/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/pwm/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport pwmio\n\n# Connect LED to PWMOut\nled = pwmio.PWMOut(board.LED, frequency=5000, duty_cycle=0)\n\nwhile True:\n    for i in range(100):\n        # PWM LED up and down\n        if i &lt; 50:\n            led.duty_cycle = int(i * 2 * 65535 / 100)  # Up\n        else:\n            led.duty_cycle = 65535 - int((i - 50) * 2 * 65535 / 100)  # Down\n        time.sleep(0.01)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Observe that the Red LED starts off increases its brightness until it is fully on and then decreases until the LED is off, completing on fade cycle.</p> </li> </ol>"},{"location":"guides/python/samples/usb/hid_keyboard/","title":"USB HID Keyboard","text":""},{"location":"guides/python/samples/usb/hid_keyboard/#overview","title":"Overview","text":"<p>The USB HID Keyboard sample demonstrates using the USB Human Interface Device (HID) module to implement a keyboard input device that you can connect to your computer.</p> <p>This sample code enumerates the iMX RT1011 Nano Kit into a HID keyboard that has an A key connected to the USR/BT button.</p> <p>Tip</p> <p><code>adafruit_hid</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/usb/hid_keyboard/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/usb/hid_keyboard/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nfrom adafruit_hid.keycode import Keycode\n\n# USR/BT button acts as A key on a keyboard\nkey_a = digitalio.DigitalInOut(board.USR_BTN)\nkey_a.direction = digitalio.Direction.INPUT\nkey_a.pull = digitalio.Pull.DOWN\n\n# Red LED indicates A key is pressed\nled = digitalio.DigitalInOut(board.LED)\nled.direction = digitalio.Direction.OUTPUT\n\n# The keyboard object!\ntime.sleep(1)  # Sleep for a bit to avoid a race condition on some systems\nkeyboard = Keyboard(usb_hid.devices)\nkeyboard_layout = KeyboardLayoutUS(keyboard)\n\nprint(\"Waiting for key pin...\")\n\nwhile True:\n    if not key_a.value:\n        print(\"Key A pressed!\")\n\n        # Turn on Red LED\n        led.value = True\n\n        while not key_a.value:\n            pass    # Wait for key A released\n\n        # Type keycode `Shift+A`\n        keyboard.press(Keycode.SHIFT, Keycode.A)\n        keyboard.release_all()\n\n        # Turn off Red LED\n        led.value = False\n\n    time.sleep(0.01)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. The board will enumerate as a HID keyboard. Click Serial on Mu Editor's Top Menu to open a serial console. You should see the console output, similar to what is shown in the following:</p> <pre><code>Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nWaiting for key pin...\n</code></pre> </li> <li> <p>Open a text editor and press USR/BT button on the board. Every button press sends a character <code>A</code> to the computer, and this will be displayed in the text editor.</p> </li> </ol>"},{"location":"guides/python/samples/usb/hid_mouse/","title":"USB HID Mouse","text":""},{"location":"guides/python/samples/usb/hid_mouse/#overview","title":"Overview","text":"<p>The USB HID Mouse sample demonstrates using the USB Human Interface Device (HID) module to implement a mouse input device that you can connect to your computer.</p> <p>This sample code enumerates the iMX RT1011 Nano Kit into a HID mouse that has a left button connected to the USR/BT button.</p> <p>Tip</p> <p><code>adafruit_hid</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/usb/hid_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/usb/hid_mouse/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nimport usb_hid\nfrom adafruit_hid.mouse import Mouse\n\nmouse = Mouse(usb_hid.devices)\n\nleft_button = digitalio.DigitalInOut(board.USR_BTN)\nleft_button.direction = digitalio.Direction.INPUT\nleft_button.pull = digitalio.Pull.DOWN\n\nwhile True:\n    if left_button.value is False:\n        mouse.click(Mouse.LEFT_BUTTON)\n        time.sleep(0.2)  # Debounce delay\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. The board will enumerate as a HID mouse. Press USR/BT button on the board, and observe that a left mouse click is activated.</p> </li> </ol>"},{"location":"guides/zephyr/","title":"Develop with Zephyr RTOS","text":""},{"location":"guides/zephyr/#introduction","title":"Introduction","text":"<p>The Zephyr Project is a Linux Foundation hosted Collaboration Project. It\u2019s an open-source collaborative effort uniting developers and users in building a best-in-class small, scalable real\u2043time operating system (RTOS) optimized for resource-constrained devices, across multiple architectures.</p>"},{"location":"guides/zephyr/#key-features","title":"Key Features","text":"<ul> <li>Open-source real time operating system, with vibrant community participation</li> <li>Comprehensive, lightweight, kernel &amp; supporting services, inherently portable &amp; secure</li> <li>Complete, fully integrated, highly configurable, modular for flexibility</li> <li>Fully connected with Bluetooth 5.0 &amp; BLE, Wi-Fi, Ethernet, CANbus, IoT protocols like CoAP, LwM2M, MQTT, OpenThread and USB &amp; USB-C</li> <li>Developer-friendly, logging, tracing, debugging, built-in shell, Windows/Linux/macOS support</li> <li>Product development ready using LTS that includes security updates</li> <li>Permissively licensed - Apache 2.0 with vendor neutral governance, broad SoC, board and sensor support</li> </ul>"},{"location":"guides/zephyr/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. The following sections take you through the basics of Zephyr application development on iMX RT1011 Nano Kit.</p> <ul> <li> <p>Setting up the environment</p> <p>Learn how to set up a command-line Zephyr development environment.</p> <p> Learn more</p> </li> <li> <p>Building and running the first sample</p> <p>Learn how to build and run the first sample Blinky.</p> <p> Learn more</p> </li> <li> <p>More samples</p> <p>Explore more samples running on iMX RT1011 Nano Kit.</p> <p> Explore more</p> </li> </ul>"},{"location":"guides/zephyr/#reference","title":"Reference","text":"<ul> <li>Primary Git Repository for Zephyr</li> <li>Zephyr Project Documentation</li> </ul>"},{"location":"guides/zephyr/building/","title":"Building and running the first sample","text":"<p>This guide explains how to build and run the first sample (for example, Blinky).</p> <p>Before you start building, remember to set up the environment first.</p>"},{"location":"guides/zephyr/building/#build-the-blinky-sample","title":"Build the Blinky sample","text":"<p>After completing the environment setup, use the following steps to build the Blinky sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/blinky\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/blinky -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/building/#flash-and-run-the-sample","title":"Flash and run the sample","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash and run the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press the RST button on the board and the Red LED will start to blink.</li> <li>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board.</li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\n...\n</code></pre> </li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the Red LED will start to blink.</li> <li>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board.</li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/building/#next-steps","title":"Next steps","text":"<p>Explore more samples running on iMX RT1011 Nano Kit:</p> <ul> <li>Hello World \u2013 Print <code>Hello World</code> to the console over USB serial console</li> <li>Blinky \u2013 Blink an LED forever using the GPIO API</li> <li>Button \u2013 Demonstrate the use of GPIO input with interrupts</li> <li>ADC \u2013 Demonstrate the use of the ADC driver API</li> <li>PWM \u2013 Demonstrate the use of the PWM driver API</li> <li>Shell \u2013 Demonstrate how to register custom commands into the Zephyr shell</li> <li>USB HID Keyboard \u2013 Demonstrate the HID Keyboard implementation</li> <li>USB HID Mouse \u2013 Demonstrate the HID Mouse implementation</li> </ul> <p>Zephyr also provide a variety of application samples and demos. Documentation for those is available in:</p> <ul> <li>Zephyr's Samples and Demos</li> </ul>"},{"location":"guides/zephyr/setup/","title":"Setting up the environment","text":"<p>To start developing with the Zephyr RTOS, you should set up your development environment. This guide shows you how to set up a command-line Zephyr development environment on Ubuntu, macOS, or Windows manually.</p> <p>For more details, please refer to the latest Zephyr Project Documentation</p>"},{"location":"guides/zephyr/setup/#select-and-update-os","title":"Select and Update OS","text":"<p>Install available updates for your operating system:</p> WindowsmacOSUbuntu <p>Select Start &gt; Settings &gt; Update &amp; Security &gt; Windows Update. Click Check for updates and install any that are available.</p> <p>On macOS Mojave or later, select System Preferences... &gt; Software Update. Click Update Now if necessary.</p> <p>On other versions, see this Apple support topic.</p> <p>This guide covers Ubuntu version 20.04 LTS and later.</p> <pre><code>sudo apt update\n</code></pre> <pre><code>sudo apt upgrade\n</code></pre>"},{"location":"guides/zephyr/setup/#install-dependencies","title":"Install dependencies","text":"<p>Next, you\u2019ll install some host dependencies using your package manager.</p> <p>The current minimum required version for the main dependencies are:</p> Tool Min. Version CMake 3.20.5 Python 3.10 Devicetree compiler 1.4.6 WindowsmacOSUbuntu <p>We use Chocolatey to install dependencies here. If Chocolatey isn\u2019t an option, you can install dependencies from their respective websites and ensure the command line tools added in your <code>PATH</code> environment variable.</p> <ol> <li> <p>Install chocolatey.</p> </li> <li> <p>Open a <code>cmd.exe</code> window as Administrator. To do so, press the Windows key Win , type <code>cmd.exe</code>, right-click the result, and choose Run as Administrator.</p> </li> <li> <p>Disable global confirmation to avoid having to confirm the installation of individual programs:</p> <pre><code>choco feature enable -n allowGlobalConfirmation\n</code></pre> </li> <li> <p>Use <code>choco</code> to install the required dependencies:</p> <pre><code>choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'\n</code></pre> <pre><code>choco install ninja gperf python311 git dtc-msys2 wget unzip\n</code></pre> </li> <li> <p>Close the window and open a new <code>cmd.exe</code> window as a regular user to continue.</p> </li> </ol> <p>Tip</p> <p>To check the list of installed packages and their versions, run the following command:</p> <pre><code>choco list -lo\n</code></pre> <ol> <li> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> </li> <li> <p>After the Homebrew installation script completes, follow the on-screen instructions to add the Homebrew installation to the path.</p> <ul> <li> <p>On macOS running on Apple Silicon, this is achieved with:</p> <pre><code>(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n</code></pre> <pre><code>source ~/.zprofile\n</code></pre> </li> <li> <p>On macOS running on Intel, use the command for Apple Silicon, but replace <code>/opt/homebrew/</code> with <code>/usr/local/</code>.</p> </li> </ul> </li> <li> <p>Use <code>brew</code> to install the required dependencies:</p> <pre><code>brew install cmake ninja gperf python3 ccache qemu dtc libmagic wget openocd\n</code></pre> </li> <li> <p>Add the Homebrew Python folder to the path, in order to be able to execute <code>python</code> and <code>pip</code> as well <code>python3</code> and <code>pip3</code>.</p> <pre><code>(echo; echo 'export PATH=\"'$(brew --prefix)'/opt/python/libexec/bin:$PATH\"') &gt;&gt; ~/.zprofile\n</code></pre> <pre><code>source ~/.zprofile\n</code></pre> </li> </ol> <p>Tip</p> <p>To check the versions of these dependencies installed, run the following command:</p> <pre><code>brew list --versions\n</code></pre> <ol> <li> <p>If using an Ubuntu version older than 22.04, it is necessary to add extra repositories to meet the minimum required versions for the main dependencies listed above. In that case, download, inspect and execute the Kitware archive script to add the Kitware APT repository to your sources list. A detailed explanation of <code>kitware-archive.sh</code> can be found here kitware third-party apt repository:</p> <pre><code>wget https://apt.kitware.com/kitware-archive.sh\n</code></pre> <pre><code>sudo bash kitware-archive.sh\n</code></pre> </li> <li> <p>Use <code>apt</code> to install the required dependencies:</p> <pre><code>sudo apt install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget \\\npython3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\nmake gcc gcc-multilib g++-multilib libsdl2-dev libmagic1\n</code></pre> </li> <li> <p>Verify the versions of the main dependencies installed on your system by entering:</p> <pre><code>cmake --version\n</code></pre> <pre><code>python3 --version\n</code></pre> <pre><code>dtc --version\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/setup/#get-the-code-and-install-python-dependencies","title":"Get the code and install Python dependencies","text":"<p>To help you quickly build and run the samples on iMX RT1011 Nano Kit, the primary imxrt1011-nanokit repository contains the Zephyr manifest repositories, additional hardware drivers and tested samples, etc.</p> <p>Tip</p> <p>It is easy to run into Python package incompatibilities when installing dependencies at a system or user level. This situation can happen, for example, if working on multiple Zephyr versions or other projects using Python on the same machine.</p> <p>For this reason it is suggested to use Python virtual environments.</p> WindowsmacOSUbuntu <ol> <li> <p>Open a <code>cmd.exe</code> terminal window as a regular user</p> </li> <li> <p>Change to <code>%HOMEPATH%</code> and create a workspace folder <code>zephyrproject</code> where all the required repositories will be cloned.</p> </li> <li> <p>Create a new virtual environment:</p> <pre><code>python -m venv zephyrproject\\.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>zephyrproject\\.venv\\Scripts\\activate.bat\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install west:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the source code:</p> <pre><code>west init -m https://github.com/makerdiary/imxrt1011-nanokit --mr main zephyrproject\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd zephyrproject\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>zephyrproject\n|___ .west\n|___ imxrt1011-nanokit\n|___ modules\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>Zephyr\u2019s <code>scripts\\requirements.txt</code> file declares additional Python dependencies. Install them with <code>pip</code>.</p> <pre><code>pip install -r %HOMEPATH%\\zephyrproject\\zephyr\\scripts\\requirements.txt\n</code></pre> </li> </ol> <ol> <li>Open up a terminal window.</li> <li>Change to <code>~</code> and create a workspace folder <code>zephyrproject</code> where all the required repositories will be cloned.</li> <li> <p>Create a new virtual environment:</p> <pre><code>python3 -m venv ~/zephyrproject/.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>source ~/zephyrproject/.venv/bin/activate\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install west:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the source code:</p> <pre><code>west init -m https://github.com/makerdiary/imxrt1011-nanokit --mr main zephyrproject\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd zephyrproject\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>zephyrproject\n|___ .west\n|___ imxrt1011-nanokit\n|___ modules\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>Zephyr\u2019s <code>scripts\\requirements.txt</code> file declares additional Python dependencies. Install them with <code>pip</code>.</p> <pre><code>pip install -r ~/zephyrproject/zephyr/scripts/requirements.txt\n</code></pre> </li> </ol> <ol> <li>Open up a terminal window.</li> <li>Change to <code>~</code> and create a workspace folder <code>zephyrproject</code> where all the required repositories will be cloned.</li> <li> <p>Use <code>apt</code> to install Python <code>venv</code> package:</p> <pre><code>sudo apt install python3-venv\n</code></pre> </li> <li> <p>Create a new virtual environment:</p> <pre><code>python3 -m venv ~/zephyrproject/.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>source ~/zephyrproject/.venv/bin/activate\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install west:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the source code:</p> <pre><code>west init -m https://github.com/makerdiary/imxrt1011-nanokit --mr main zephyrproject\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd zephyrproject\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>zephyrproject\n|___ .west\n|___ imxrt1011-nanokit\n|___ modules\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>Zephyr\u2019s <code>scripts\\requirements.txt</code> file declares additional Python dependencies. Install them with <code>pip</code>.</p> <pre><code>pip install -r ~/zephyrproject/zephyr/scripts/requirements.txt\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/setup/#install-the-zephyr-sdk","title":"Install the Zephyr SDK","text":"<p>The Zephyr Software Development Kit (SDK) contains toolchains for each of Zephyr\u2019s supported architectures, which include a compiler, assembler, linker and other programs required to build Zephyr applications.</p> <p>It also contains additional host tools, such as custom QEMU and OpenOCD builds that are used to emulate, flash and debug Zephyr applications.</p> WindowsmacOSUbuntu <ol> <li>Open a <code>cmd.exe</code> terminal window as a regular user.</li> <li> <p>Download the Zephyr SDK bundle:</p> <pre><code>cd %HOMEPATH%\n</code></pre> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.5-1/zephyr-sdk-0.16.5-1_windows-x86_64.7z\n</code></pre> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>7z x zephyr-sdk-0.16.5-1_windows-x86_64.7z\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>%HOMEPATH%</code></li> <li><code>%PROGRAMFILES%</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-&lt;version&gt;</code> directory and, when extracted under <code>%HOMEPATH%</code>, the resulting installation path will be <code>%HOMEPATH%\\zephyr-sdk-&lt;version&gt;</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.16.5-1\n</code></pre> <pre><code>setup.cmd\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> </ol> <ol> <li> <p>Download and verify the Zephyr SDK bundle:</p> <pre><code>cd ~\n</code></pre> <pre><code>curl -L -O https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.5-1/zephyr-sdk-0.16.5-1_macos-x86_64.tar.xz\n</code></pre> <pre><code>curl -L https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.5-1/sha256.sum | shasum --check --ignore-missing\n</code></pre> <p>If your host architecture is 64-bit ARM (Apple Silicon, also known as M1), replace <code>x86_64</code> with <code>aarch64</code> in order to download the 64-bit ARM macOS SDK.</p> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>tar xvf zephyr-sdk-0.16.5-1_macos-x86_64.tar.xz\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>$HOME</code></li> <li><code>$HOME/.local</code></li> <li><code>$HOME/.local/opt</code></li> <li><code>$HOME/bin</code></li> <li><code>/opt</code></li> <li><code>/usr/local</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-&lt;version&gt;</code> directory and, when extracted under <code>$HOME</code>, the resulting installation path will be <code>$HOME/zephyr-sdk-&lt;version&gt;</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.16.5-1\n</code></pre> <pre><code>./setup.sh\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> </ol> <ol> <li> <p>Download and verify the Zephyr SDK bundle:</p> <pre><code>cd ~\n</code></pre> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.5-1/zephyr-sdk-0.16.5-1_linux-x86_64.tar.xz\n</code></pre> <pre><code>wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.5-1/sha256.sum | shasum --check --ignore-missing\n</code></pre> <p>If your host architecture is 64-bit ARM (for example, Raspberry Pi), replace <code>x86_64</code> with <code>aarch64</code> in order to download the 64-bit ARM Linux SDK.</p> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>tar xvf zephyr-sdk-0.16.5-1_linux-x86_64.tar.xz\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>$HOME</code></li> <li><code>$HOME/.local</code></li> <li><code>$HOME/.local/opt</code></li> <li><code>$HOME/bin</code></li> <li><code>/opt</code></li> <li><code>/usr/local</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-&lt;version&gt;</code> directory and, when extracted under <code>$HOME</code>, the resulting installation path will be <code>$HOME/zephyr-sdk-&lt;version&gt;</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.16.5-1\n</code></pre> <pre><code>./setup.sh\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> <li> <p>Install udev rules, which allow you to flash most Zephyr boards as a regular user:</p> <pre><code>sudo cp ~/zephyr-sdk-0.16.5-1/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d\n</code></pre> <pre><code>sudo udevadm control --reload\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/","title":"Samples","text":"<p>We think the best way to learn is by doing. A set of samples are provided in the imxrt1011-nanokit repository.</p> <ul> <li>Hello World \u2013 Print <code>Hello World</code> to the console over USB serial console</li> <li>Blinky \u2013 Blink an LED forever using the GPIO API</li> <li>Button \u2013 Demonstrate the use of GPIO input with interrupts</li> <li>ADC \u2013 Demonstrate the use of the ADC driver API</li> <li>PWM \u2013 Demonstrate the use of the PWM driver API</li> <li>Shell \u2013 Demonstrate how to register custom commands into the Zephyr shell</li> <li>USB HID Keyboard \u2013 Demonstrate the HID Keyboard implementation</li> <li>USB HID Mouse \u2013 Demonstrate the HID Mouse implementation</li> </ul>"},{"location":"guides/zephyr/samples/adc/","title":"ADC","text":""},{"location":"guides/zephyr/samples/adc/#overview","title":"Overview","text":"<p>This sample demonstrates how to use the ADC driver API. It reads ADC samples from all the available channels and prints the readings on the console. If voltage of the used reference can be obtained, the raw readings are converted to millivolts.</p>"},{"location":"guides/zephyr/samples/adc/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/adc/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the ADC sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/adc\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/adc -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/adc/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/adc/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Plug the board into the USB port of your computer.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nADC reading[0]:\n- adc@400c4000, channel 0: 118 = 95 mV\n- adc@400c4000, channel 1: 78 = 62 mV\n- adc@400c4000, channel 2: 85 = 68 mV\n- adc@400c4000, channel 3: 93 = 74 mV\n- adc@400c4000, channel 4: 90 = 72 mV\n- adc@400c4000, channel 5: 97 = 78 mV\n- adc@400c4000, channel 6: 91 = 73 mV\n- adc@400c4000, channel 7: 87 = 70 mV\n- adc@400c4000, channel 8: 3517 = 2833 mV\n- adc@400c4000, channel 9: 333 = 268 mV\n- adc@400c4000, channel 10: 3596 = 2897 mV\n- adc@400c4000, channel 11: 322 = 259 mV\n- adc@400c4000, channel 12: 84 = 67 mV\n- adc@400c4000, channel 13: 3640 = 2932 mV\n- adc@400c4000, channel 14: 3842 = 3095 mV\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/blinky/","title":"Blinky","text":""},{"location":"guides/zephyr/samples/blinky/#overview","title":"Overview","text":"<p>The Blinky sample blinks an LED forever using the GPIO API.</p> <p>The source code shows how to:</p> <ol> <li> <p>Get a pin specification from the devicetree as a <code>gpio_dt_spec</code></p> </li> <li> <p>Configure the GPIO pin as an output</p> </li> <li> <p>Toggle the pin forever</p> </li> </ol>"},{"location":"guides/zephyr/samples/blinky/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/blinky/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Blinky sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/blinky\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/blinky -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/blinky/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/blinky/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li> <p>Observe the Red LED on the board which will blink every 0.5 second.</p> </li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\nLED state: OFF\nLED state: ON\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/button/","title":"Button","text":""},{"location":"guides/zephyr/samples/button/#overview","title":"Overview","text":"<p>A simple button sample demonstrates the use of GPIO input with interrupts. The sample prints a message to the console each time a button is pressed.</p>"},{"location":"guides/zephyr/samples/button/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/button/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Button sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/button\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/button -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/button/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/button/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Plug the board into the USB port of your computer.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal and press the button. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nSet up button at gpio@42000000 pin 3\nSet up LED at gpio@42000000 pin 4\nPress the button\nButton pressed at 4032517958\nButton pressed at 2753680012\nButton pressed at 4157128456\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/hello_world/","title":"Hello World","text":""},{"location":"guides/zephyr/samples/hello_world/#overview","title":"Overview","text":"<p>The Hello World sample can be used as a start point of Zephyr application development. This sample is quite simple and just prints <code>Hello World</code> to the console over USB serial console.</p>"},{"location":"guides/zephyr/samples/hello_world/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/hello_world/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Hello World sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/hello_world\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/hello_world -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/hello_world/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/hello_world/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Plug the board into the USB port of your computer.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nHello World! imxrt1011_nanokit/mimxrt1011\nHello World! imxrt1011_nanokit/mimxrt1011\nHello World! imxrt1011_nanokit/mimxrt1011\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/pwm/","title":"PWM","text":""},{"location":"guides/zephyr/samples/pwm/#overview","title":"Overview","text":"<p>This sample uses the PWM API to fade an LED. The LED starts off increases its brightness until it is fully or nearly fully on. The brightness then decreases until the LED is off, completing on fade cycle.</p>"},{"location":"guides/zephyr/samples/pwm/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/pwm/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the PWM sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/pwm\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/pwm -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/pwm/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/pwm/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li> <p>Observe the Red LED on the board starts off increases its brightness until it is fully or nearly fully on. The brightness then decreases until the LED is off, completing on fade cycle.</p> </li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\nPWM-based LED fade\nThe LED is fully on.\nThe LED is fully off.\nThe LED is fully on.\nThe LED is fully off.\nThe LED is fully on.\nThe LED is fully off.\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/shell/","title":"Shell","text":""},{"location":"guides/zephyr/samples/shell/#overview","title":"Overview","text":"<p>The Shell sample shows you how to register custom commands into the Zephyr Shell. The following custom commands will be registered:</p> <ul> <li><code>bootloader</code>: Enter the UF2 Bootloader at runtime.</li> <li><code>erase_app</code>: Erase the entire application at runtime.</li> </ul> <p>Ensure UF2 Bootloader is present</p> <p>This sample requires the UF2 Bootloader running on the board. If the UF2 Bootloader is not present or gets corrupted somehow, you can re-install the UF2 Bootloader by following the UF2 Bootloader Installation section.</p>"},{"location":"guides/zephyr/samples/shell/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/shell/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Shell sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>.</p> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/shell\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/shell/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>This sample should work with the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/shell/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Plug the board into the USB port of your computer.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>After connecting to the shell you should see the following output::</p> <pre><code>*** Booting Zephyr OS build v3.6.0-3959-gd0ae1a8b1057 ***\n\n\nuart:~$\n</code></pre> </li> <li> <p>The <code>bootloader</code> command can now be used:</p> <pre><code>uart:~$ bootloader\nEnter UF2 Bootloader...\n</code></pre> <p>After this command is executed, the board will reset and run into the UF2 Bootloader mode.</p> </li> <li> <p>Press RST button to exit the UF2 Bootloader mode and run into the Shell application. Connect to the shell again.</p> </li> <li> <p>The <code>erase_app</code> command can now be used:</p> <pre><code>uart:~$ erase_app\nDon't turn off the power! Erasing entire application...\n</code></pre> <p>After this command is executed, the board will reset and start erasing the application memory. The Red LED will blink fast, and once erasing completed, the board will run in UF2 Bootloader mode as there is no application to boot.</p> </li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_keyboard/","title":"USB HID Keyboard","text":""},{"location":"guides/zephyr/samples/usb/hid_keyboard/#overview","title":"Overview","text":"<p>The USB HID Keyboard sample demonstrates the HID keyboard implementation using Zephyr's USB Human Interface Device (HID) driver. Pressing the USR/BT button on the board emulates a Caps Lock key Caps Lock press. The Red LED is used to indicate the state of Caps Lock Caps Lock.</p>"},{"location":"guides/zephyr/samples/usb/hid_keyboard/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/usb/hid_keyboard/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the USB HID Keyboard sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/usb/hid-keyboard\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/usb/hid-keyboard -- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_keyboard/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_keyboard/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>The board will be detected as a HID keyboard named Zephyr HID Keyboard.</li> <li>Press USR/BT button on the board and you can see the Caps Lock Caps Lock on your computer activated and the Red LED turns on.</li> <li>Press USR/BT button again and you can see the Caps Lock Caps Lock deactivated and the Red LED turns off.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\n[00:00:00.000,000] &lt;inf&gt; main: HID keyboard sample is initialized\n[00:00:00.105,000] &lt;inf&gt; usb_hid: Device reset detected\n[00:00:00.177,000] &lt;inf&gt; usb_hid: Device configured\n[00:00:04.662,000] &lt;inf&gt; main: Report sent:\n                            00 00 39 00 00 00 00 00                          |..9.....\n[00:00:04.886,000] &lt;inf&gt; main: Report sent:\n                            00 00 00 00 00 00 00 00                          |........\n[00:00:06.390,000] &lt;inf&gt; main: Report sent:\n                            00 00 39 00 00 00 00 00                          |..9.....\n[00:00:06.582,000] &lt;inf&gt; main: Report sent:\n                            00 00 00 00 00 00 00 00                          |........\n...\n</code></pre> </li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_mouse/","title":"USB HID Mouse","text":""},{"location":"guides/zephyr/samples/usb/hid_mouse/#overview","title":"Overview","text":"<p>The USB HID Mouse sample demonstrates the use of a USB Human Interface Device (HID) driver by the Zephyr project. This very simple driver enumerates a board with a button into a mouse that has a left mouse button and optionally (depending on the number of buttons on the board) a right mouse button, X-axis movement, and Y-axis movement. If the USB peripheral driver supports remote wakeup feature, wakeup request will be performed on every button click if the bus is in suspended state.</p>"},{"location":"guides/zephyr/samples/usb/hid_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x iMX RT1011 Nano Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/zephyr/samples/usb/hid_mouse/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the USB HID Mouse sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>zephyrproject/imxrt1011-nanokit</code> directory created in the Setting up the environment section.</p> <pre><code>cd zephyrproject/imxrt1011-nanokit\n</code></pre> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>imxrt1011_nanokit</code>. To build the sample when working without the UF2 Bootloader, specify <code>-DEXTRA_CONF_FILE=overlay-nouf2.conf</code>.</p> UF2 (default)No UF2 <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/usb/hid-mouse\n</code></pre> <pre><code>west build -p always -b imxrt1011_nanokit samples/zephyr/usb/hid-mouse-- -DEXTRA_CONF_FILE=overlay-nouf2.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_mouse/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample works with/without the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code>.</p> <p>To flash the firmware, complete the following steps:</p> UF2 (default)No UF2 <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop <code>build/zephyr/zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Press RST button on the board and the sample will start running.</li> </ol> <ol> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>Follow Generating bootable image section to convert <code>build/zephyr/zephyr.hex</code> into a bootable image.</li> <li>Follow Writing the bootable image section to flash the firmware.</li> <li>Press the RST button on the board and the sample will start running.</li> </ol>"},{"location":"guides/zephyr/samples/usb/hid_mouse/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect iMX RT1011 Nano Kit to your computer using the USB-C Cable.</li> <li>The board will be detected as a HID mouse named Zephyr HID Mouse.</li> <li>Press the USR/BT button on the board. Observe that a left mouse click is activated and the Red LED blinks.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>*** Booting Zephyr OS build v3.7.0-189-g988e4cf77094 ***\n[00:00:00.104,000] &lt;inf&gt; usb_hid: Device reset detected\n[00:00:00.174,000] &lt;inf&gt; usb_hid: Device configured\n...\n</code></pre> </li> </ol>"},{"location":"programming/","title":"iMX RT1011 Nano Kit Programming Guide","text":"<p>iMX RT1011 Nano Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the <code>.uf2</code>-format images to the flash drive.</p> <p>In addition, you can always enter the ROM Serial Downloader even when the UF2 Bootloader gets corrupted somehow and use the MCUXpresso Secure Provisioning Tool to build and write the images to the board.</p> <ul> <li> <p>Programming with UF2 Bootloader</p> <p>Learn how to install UF2 Bootloader on iMX RT1011 Nano Kit and flash the application code in UF2.</p> <p> Learn more</p> </li> <li> <p>MCUXpresso Secure Provisioning Tool</p> <p>Learn how to use MCUXpresso Secure Provisioning Tool to prepare and flash images.</p> <p> Learn more</p> </li> </ul>"},{"location":"programming/mcuxpresso-secure-provisioning/","title":"MCUXpresso Secure Provisioning Tool","text":"<p>The MCUXpresso Secure Provisioning Tool is a GUI-based application provided to simplify generation and provisioning of bootable executables on NXP MCU devices.</p> <p>This section show you how to program iMX RT1011 Nano Kit using MCUXpresso Secure Provisioning Tool.</p> <p>For more details about MCUXpresso Secure Provisioning Tool, please refer to the MCUXpresso Secure Provisioning Tool User Guide.</p> <p></p>"},{"location":"programming/mcuxpresso-secure-provisioning/#installation","title":"Installation","text":"<p>The MCUXpresso Secure Provisioning Tool runs on the macOS, Linux, and Windows operating systems. Visit the NXP website (https://www.nxp.com/mcuxpresso/secure) to download the MCUXpresso Secure Provisioning Tool for your operating system. Here we use the version <code>V8.0</code>.</p> <p>Start the installer and follow the wizard to finish the installation.</p>"},{"location":"programming/mcuxpresso-secure-provisioning/#generating-bootable-image","title":"Generating bootable image","text":"<p>Before writing image into the external flash memory of iMX RT1011 Nano Kit, you need to convert the prepared application into a bootable image.</p> <p>Here, we take for example the blinky.hex, showing how to generate it into a bootable image.</p> <ol> <li> <p>Start MCUXpresso Secure Provisioning Tool, then select the <code>MIMXRT1010 (MIMXRT1011xxxxx)</code> processor in the New Workspace window and click Create.</p> <p></p> </li> <li> <p>Make sure that Boot Type is Unsigned.</p> </li> <li> <p>Config the Boot Memory:</p> <ol> <li>Set Boot memory type to FlexSPI NOR - simplified</li> <li>Apply Predefined template AT25SF128A</li> <li>Click OK to finish Boot Memory Configuration</li> </ol> <p></p> </li> <li> <p>Switch to the Build image tab.</p> </li> <li>Select the Source executable image that is, for example, the blinky.hex.</li> <li>Click Build Image button to generate the bootable image.</li> </ol> <p></p>"},{"location":"programming/mcuxpresso-secure-provisioning/#writing-the-bootable-image","title":"Writing the bootable image","text":"<p>Now, you can write the image that was generated above into the external flash memory of iMX RT1011 Nano Kit:</p> <ol> <li>Switch to the Write image tab.</li> <li>Make sure that the Use built image option is selected.</li> <li>Push and hold the USR/BT button and plug your board into the USB port of your computer.</li> <li>The board will run into Boot ROM Serial Download mode.</li> <li>Click Write Image button to start programming.</li> <li>When finished, press the RST button on the board. The image will start running.</li> </ol> <p></p> <p>Warning</p> <p>The MCUXpresso Secure Provisioning Tool will overwrite the flash memory area of UF2 Bootloader after performing writing image. You can follow the UF2 Bootloader Installation section to re-install the UF2 Bootloader if needed.</p>"},{"location":"programming/uf2boot/","title":"Update firmware using the UF2 Bootloader","text":""},{"location":"programming/uf2boot/#overview","title":"Overview","text":"<p>iMX RT1011 Nano Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the <code>.uf2</code>-format images to the flash drive without using an external programmer.</p> <p>UF2 Bootloader runs entirely on SRAM which is not only super fast but also easy to perform self-update. After powering on, if UF2 Bootloader already exists on external flash, it will be loaded to internal SRAM and start executing from there.</p> <p>This section details how to update firmware using the UF2 Bootloader.</p>"},{"location":"programming/uf2boot/#external-flash-memory-layout","title":"External flash memory layout","text":"<p>When updating firmware using the UF2 Bootloader, you must be aware of where in the external flash memory the bootloader and the application firmware are located.</p> <p>The following figure shows the default external flash memory layout of iMX RT1011 Nano Kit:</p> Usage Memory location Size Flash Config 0x60000400 0x00000C00 (3 KB) Image Vector Table (IVT) 0x60001000 0x00001000 (4 KB) Interrupts 0x60002000 0x00000400 (1 KB) Bootloader 0x60002400 0x0000A000 (40 KB) Application 0x6000C000 16 MB - 48 KB <p>Note</p> <p>The application firmware must start from <code>0x6000C000</code> when the UF2 Bootloader is present, so that the bootloader can find the application and boot it.</p>"},{"location":"programming/uf2boot/#installing-uf2-bootloader","title":"Installing UF2 Bootloader","text":"<p>The i.MX RT has built-in bootloader in ROM that implements the NXP Serial Download Protocol (SDP), which can be used to load &amp; execute UF2 Bootloader to SRAM with <code>spdhost</code> tool via USB.</p> <p>To install the UF2 Bootloader, complete the following steps:</p> <ol> <li> <p>Follow the SPSDK Installation Guide to install NXP SPSDK.</p> </li> <li> <p>Verify the <code>spdhost</code> tool by running the following command:</p> <pre><code>spdhost --version\n</code></pre> </li> <li> <p>Push and hold the USR/BT button and plug your board into the USB port of your computer.</p> </li> <li>A new USB device named <code>SE Blank RT Family</code> will be detected by your computer.</li> <li>Download the lastest UF2 Bootloader firmware. The bootloader is located in firmware/uf2_bootloader with the name <code>uf2_bootloader-imxrt1011_nanokit-&lt;version&gt;.bin</code>.</li> <li> <p>Open up a terminal window and run two commands with <code>sdphost</code>, changing the name of the <code>.bin</code> file as appropriate:</p> <p><pre><code>sdphost -u 0x1fc9,0x0145 write-file 0x20206400 uf2_bootloader-imxrt1011_nanokit-&lt;version&gt;.bin\n</code></pre> <pre><code>sdphost -u 0x1fc9,0x0145 jump-address 0x20207000\n</code></pre></p> </li> <li> <p>Re-plug the board or press the RST button, the UF2 bootloader will start running and the board will mount as a Mass Storage Device called UF2BOOT.</p> <p></p> </li> </ol>"},{"location":"programming/uf2boot/#updating-the-uf2-bootloader","title":"Updating the UF2 Bootloader","text":"<p>The UF2 Bootloader is self-upgradable, and you can simply drag &amp; drop an update file in <code>.uf2</code> format into UF2BOOT to update. This way is quite easy and highly recommended when updating the UF2 Bootloader to newer version.</p> <p>To update the bootloader, complete the following steps:</p> <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li> <p>Open <code>INFO_UF2.TXT</code> in the UF2BOOT volume with a text editor, and check the current version of bootloader. The figure below shows we are running the <code>0.18.2</code> version.     </p> </li> <li> <p>Check if newer updates are available in the firmware/uf2_bootloader folder. The update file is released with the name <code>update-uf2_bootloader-imxrt1011_nanokit-&lt;version&gt;.uf2</code>.</p> </li> <li>Drag and drop the update file into the UF2BOOT volume.</li> <li>Re-plug the board and enter UF2 Bootloader mode again, then verify the version printed in <code>INFO_UF2.TXT</code>.</li> </ol>"},{"location":"programming/uf2boot/#flashing-application-firmware","title":"Flashing application firmware","text":"<p>It is quite easy to flash the application firmware, just simply dragging &amp; dropping any compatible UF2 file onto the UF2BOOT volume.</p> <p>Warning</p> <p>Before flashing the UF2, you should make sure the firmware starts from the correct flash memory address <code>0x6000C000</code>.</p> <p>To flash your application firmware, just follow the steps below:</p> <ol> <li>Plug your board into the USB port of your computer.</li> <li>Double-click the RST button to enter UF2 Bootloader mode.</li> <li>The board will mount as a Mass Storage Device called UF2BOOT and the Red LED blinks slow.</li> <li>Drag and drop the UF2 file onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Re-plug or click RST button to reset the board, then the new application firmware will start running.</li> </ol>"},{"location":"programming/uf2boot/#generating-uf2-file-from-hex-or-bin","title":"Generating UF2 file from <code>.hex</code> or <code>.bin</code>","text":"<p>Before flashing the <code>.hex</code> or <code>.bin</code> firmware, you need to generate them to <code>.uf2</code> format. The following steps show you how to generate UF2 file from <code>.hex</code> or <code>.bin</code> file:</p> <ol> <li>Make sure that you have Python 3.6.0 or later installed.</li> <li> <p>Install UF2 Converter. Open up a terminal and run the following command to install the latest prerelease version from the HEAD of the main branch:</p> WindowsLinux/macOS <pre><code>py -3 -m pip install --pre -U git+https://github.com/makerdiary/uf2utils.git@main\n</code></pre> <pre><code>python3 -m pip install --pre -U git+https://github.com/makerdiary/uf2utils.git@main\n</code></pre> </li> <li> <p>Verify the <code>uf2conv</code> tool by running the following command:</p> <pre><code>uf2conv --help\n</code></pre> </li> <li> <p>To generate UF2 file, simply use <code>uf2conv</code> on a <code>.hex</code> or <code>.bin</code> file, specifying the family as <code>0x4fb2d5bd</code>:</p> Generating from <code>.hex</code>Generating from <code>.bin</code> <pre><code>uf2conv -f 0x4fb2d5bd -c -o application.uf2 application.hex\n</code></pre> <pre><code>uf2conv -f 0x4fb2d5bd -c -b 0x6000C000 -o application.uf2 application.bin\n</code></pre> </li> </ol>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#technical-documentation","title":"Technical documentation","text":"<ul> <li>iMX RT011 Nano Kit Product Brief</li> <li>iMX RT1011 Nano Kit Quick Start Guide</li> <li>iMX RT1011 Nano Kit Programming Guide</li> <li>Develop with Zephyr RTOS</li> <li>Code in Python</li> </ul>"},{"location":"resources/#hardware-resource","title":"Hardware resource","text":"<ul> <li>iMX RT011 Nano Kit Pinout Rev.A</li> <li>iMX RT011 Nano Kit Hardware Description</li> <li>iMX RT011 Nano Kit Schematic Rev.A</li> <li>iMX RT011 Nano Kit 3D Model Rev.A</li> </ul>"},{"location":"resources/#regulatory-compliance","title":"Regulatory &amp; Compliance","text":"<ul> <li>FCC Supplier's Declaration of Conformity (SDoC)</li> <li>EU Declaration of Conformity (DoC)</li> <li>RoHS &amp; REACH Declaration of Conformity</li> </ul>"}]}